// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/akeemphilbert/pericarp/pkg/domain"
	"sync"
	"time"
)

// Ensure, that EventMock does implement domain.Event.
// If this is not the case, regenerate this file with moq.
var _ domain.Event = &EventMock{}

// EventMock is a mock implementation of domain.Event.
//
//	func TestSomethingThatUsesEvent(t *testing.T) {
//
//		// make and configure a mocked domain.Event
//		mockedEvent := &EventMock{
//			AccountFunc: func() string {
//				panic("mock out the Account method")
//			},
//			AggregateIDFunc: func() string {
//				panic("mock out the AggregateID method")
//			},
//			CreatedAtFunc: func() time.Time {
//				panic("mock out the CreatedAt method")
//			},
//			EventTypeFunc: func() string {
//				panic("mock out the EventType method")
//			},
//			PayloadFunc: func() []byte {
//				panic("mock out the Payload method")
//			},
//			SequenceNoFunc: func() int64 {
//				panic("mock out the GetSequenceNo method")
//			},
//			SetSequenceNoFunc: func(sequenceNo int64)  {
//				panic("mock out the SetSequenceNo method")
//			},
//			UserFunc: func() string {
//				panic("mock out the User method")
//			},
//		}
//
//		// use mockedEvent in code that requires domain.Event
//		// and then make assertions.
//
//	}
type EventMock struct {
	// AccountFunc mocks the Account method.
	AccountFunc func() string

	// AggregateIDFunc mocks the AggregateID method.
	AggregateIDFunc func() string

	// CreatedAtFunc mocks the CreatedAt method.
	CreatedAtFunc func() time.Time

	// EventTypeFunc mocks the EventType method.
	EventTypeFunc func() string

	// PayloadFunc mocks the Payload method.
	PayloadFunc func() []byte

	// SequenceNoFunc mocks the SequenceNo method.
	SequenceNoFunc func() int64

	// SetSequenceNoFunc mocks the SetSequenceNo method.
	SetSequenceNoFunc func(sequenceNo int64)

	// UserFunc mocks the User method.
	UserFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Account holds details about calls to the Account method.
		Account []struct {
		}
		// AggregateID holds details about calls to the AggregateID method.
		AggregateID []struct {
		}
		// CreatedAt holds details about calls to the CreatedAt method.
		CreatedAt []struct {
		}
		// EventType holds details about calls to the EventType method.
		EventType []struct {
		}
		// Payload holds details about calls to the Payload method.
		Payload []struct {
		}
		// SequenceNo holds details about calls to the SequenceNo method.
		SequenceNo []struct {
		}
		// SetSequenceNo holds details about calls to the SetSequenceNo method.
		SetSequenceNo []struct {
			// SequenceNo is the sequenceNo argument value.
			SequenceNo int64
		}
		// User holds details about calls to the User method.
		User []struct {
		}
	}
	lockAccount       sync.RWMutex
	lockAggregateID   sync.RWMutex
	lockCreatedAt     sync.RWMutex
	lockEventType     sync.RWMutex
	lockPayload       sync.RWMutex
	lockSequenceNo    sync.RWMutex
	lockSetSequenceNo sync.RWMutex
	lockUser          sync.RWMutex
}

// Account calls AccountFunc.
func (mock *EventMock) Account() string {
	if mock.AccountFunc == nil {
		panic("EventMock.AccountFunc: method is nil but Event.Account was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAccount.Lock()
	mock.calls.Account = append(mock.calls.Account, callInfo)
	mock.lockAccount.Unlock()
	return mock.AccountFunc()
}

// AccountCalls gets all the calls that were made to Account.
// Check the length with:
//
//	len(mockedEvent.AccountCalls())
func (mock *EventMock) AccountCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAccount.RLock()
	calls = mock.calls.Account
	mock.lockAccount.RUnlock()
	return calls
}

// AggregateID calls AggregateIDFunc.
func (mock *EventMock) AggregateID() string {
	if mock.AggregateIDFunc == nil {
		panic("EventMock.AggregateIDFunc: method is nil but Event.AggregateID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAggregateID.Lock()
	mock.calls.AggregateID = append(mock.calls.AggregateID, callInfo)
	mock.lockAggregateID.Unlock()
	return mock.AggregateIDFunc()
}

// AggregateIDCalls gets all the calls that were made to AggregateID.
// Check the length with:
//
//	len(mockedEvent.AggregateIDCalls())
func (mock *EventMock) AggregateIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAggregateID.RLock()
	calls = mock.calls.AggregateID
	mock.lockAggregateID.RUnlock()
	return calls
}

// CreatedAt calls CreatedAtFunc.
func (mock *EventMock) CreatedAt() time.Time {
	if mock.CreatedAtFunc == nil {
		panic("EventMock.CreatedAtFunc: method is nil but Event.CreatedAt was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCreatedAt.Lock()
	mock.calls.CreatedAt = append(mock.calls.CreatedAt, callInfo)
	mock.lockCreatedAt.Unlock()
	return mock.CreatedAtFunc()
}

// CreatedAtCalls gets all the calls that were made to CreatedAt.
// Check the length with:
//
//	len(mockedEvent.CreatedAtCalls())
func (mock *EventMock) CreatedAtCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCreatedAt.RLock()
	calls = mock.calls.CreatedAt
	mock.lockCreatedAt.RUnlock()
	return calls
}

// EventType calls EventTypeFunc.
func (mock *EventMock) EventType() string {
	if mock.EventTypeFunc == nil {
		panic("EventMock.EventTypeFunc: method is nil but Event.EventType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEventType.Lock()
	mock.calls.EventType = append(mock.calls.EventType, callInfo)
	mock.lockEventType.Unlock()
	return mock.EventTypeFunc()
}

// EventTypeCalls gets all the calls that were made to EventType.
// Check the length with:
//
//	len(mockedEvent.EventTypeCalls())
func (mock *EventMock) EventTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEventType.RLock()
	calls = mock.calls.EventType
	mock.lockEventType.RUnlock()
	return calls
}

// Payload calls PayloadFunc.
func (mock *EventMock) Payload() []byte {
	if mock.PayloadFunc == nil {
		panic("EventMock.PayloadFunc: method is nil but Event.Payload was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPayload.Lock()
	mock.calls.Payload = append(mock.calls.Payload, callInfo)
	mock.lockPayload.Unlock()
	return mock.PayloadFunc()
}

// PayloadCalls gets all the calls that were made to Payload.
// Check the length with:
//
//	len(mockedEvent.PayloadCalls())
func (mock *EventMock) PayloadCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPayload.RLock()
	calls = mock.calls.Payload
	mock.lockPayload.RUnlock()
	return calls
}

// SequenceNo calls SequenceNoFunc.
func (mock *EventMock) SequenceNo() int64 {
	if mock.SequenceNoFunc == nil {
		panic("EventMock.SequenceNoFunc: method is nil but Event.GetSequenceNo was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSequenceNo.Lock()
	mock.calls.SequenceNo = append(mock.calls.SequenceNo, callInfo)
	mock.lockSequenceNo.Unlock()
	return mock.SequenceNoFunc()
}

// SequenceNoCalls gets all the calls that were made to SequenceNo.
// Check the length with:
//
//	len(mockedEvent.SequenceNoCalls())
func (mock *EventMock) SequenceNoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSequenceNo.RLock()
	calls = mock.calls.SequenceNo
	mock.lockSequenceNo.RUnlock()
	return calls
}

// SetSequenceNo calls SetSequenceNoFunc.
func (mock *EventMock) SetSequenceNo(sequenceNo int64) {
	if mock.SetSequenceNoFunc == nil {
		panic("EventMock.SetSequenceNoFunc: method is nil but Event.SetSequenceNo was just called")
	}
	callInfo := struct {
		SequenceNo int64
	}{
		SequenceNo: sequenceNo,
	}
	mock.lockSetSequenceNo.Lock()
	mock.calls.SetSequenceNo = append(mock.calls.SetSequenceNo, callInfo)
	mock.lockSetSequenceNo.Unlock()
	mock.SetSequenceNoFunc(sequenceNo)
}

// SetSequenceNoCalls gets all the calls that were made to SetSequenceNo.
// Check the length with:
//
//	len(mockedEvent.SetSequenceNoCalls())
func (mock *EventMock) SetSequenceNoCalls() []struct {
	SequenceNo int64
} {
	var calls []struct {
		SequenceNo int64
	}
	mock.lockSetSequenceNo.RLock()
	calls = mock.calls.SetSequenceNo
	mock.lockSetSequenceNo.RUnlock()
	return calls
}

// User calls UserFunc.
func (mock *EventMock) User() string {
	if mock.UserFunc == nil {
		panic("EventMock.UserFunc: method is nil but Event.User was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUser.Lock()
	mock.calls.User = append(mock.calls.User, callInfo)
	mock.lockUser.Unlock()
	return mock.UserFunc()
}

// UserCalls gets all the calls that were made to User.
// Check the length with:
//
//	len(mockedEvent.UserCalls())
func (mock *EventMock) UserCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUser.RLock()
	calls = mock.calls.User
	mock.lockUser.RUnlock()
	return calls
}
