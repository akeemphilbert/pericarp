// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/akeemphilbert/pericarp/pkg/domain"
	"sync"
	"time"
)

// Ensure, that EnvelopeMock does implement domain.Envelope.
// If this is not the case, regenerate this file with moq.
var _ domain.Envelope = &EnvelopeMock{}

// EnvelopeMock is a mock implementation of domain.Envelope.
//
//	func TestSomethingThatUsesEnvelope(t *testing.T) {
//
//		// make and configure a mocked domain.Envelope
//		mockedEnvelope := &EnvelopeMock{
//			EventFunc: func() domain.Event {
//				panic("mock out the Event method")
//			},
//			EventIDFunc: func() string {
//				panic("mock out the EventID method")
//			},
//			MetadataFunc: func() map[string]interface{} {
//				panic("mock out the Metadata method")
//			},
//			TimestampFunc: func() time.Time {
//				panic("mock out the Timestamp method")
//			},
//		}
//
//		// use mockedEnvelope in code that requires domain.Envelope
//		// and then make assertions.
//
//	}
type EnvelopeMock struct {
	// EventFunc mocks the Event method.
	EventFunc func() domain.Event

	// EventIDFunc mocks the EventID method.
	EventIDFunc func() string

	// MetadataFunc mocks the Metadata method.
	MetadataFunc func() map[string]interface{}

	// TimestampFunc mocks the Timestamp method.
	TimestampFunc func() time.Time

	// calls tracks calls to the methods.
	calls struct {
		// Event holds details about calls to the Event method.
		Event []struct {
		}
		// EventID holds details about calls to the EventID method.
		EventID []struct {
		}
		// Metadata holds details about calls to the Metadata method.
		Metadata []struct {
		}
		// Timestamp holds details about calls to the Timestamp method.
		Timestamp []struct {
		}
	}
	lockEvent     sync.RWMutex
	lockEventID   sync.RWMutex
	lockMetadata  sync.RWMutex
	lockTimestamp sync.RWMutex
}

// Event calls EventFunc.
func (mock *EnvelopeMock) Event() domain.Event {
	if mock.EventFunc == nil {
		panic("EnvelopeMock.EventFunc: method is nil but Envelope.Event was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEvent.Lock()
	mock.calls.Event = append(mock.calls.Event, callInfo)
	mock.lockEvent.Unlock()
	return mock.EventFunc()
}

// EventCalls gets all the calls that were made to Event.
// Check the length with:
//
//	len(mockedEnvelope.EventCalls())
func (mock *EnvelopeMock) EventCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEvent.RLock()
	calls = mock.calls.Event
	mock.lockEvent.RUnlock()
	return calls
}

// EventID calls EventIDFunc.
func (mock *EnvelopeMock) EventID() string {
	if mock.EventIDFunc == nil {
		panic("EnvelopeMock.EventIDFunc: method is nil but Envelope.EventID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockEventID.Lock()
	mock.calls.EventID = append(mock.calls.EventID, callInfo)
	mock.lockEventID.Unlock()
	return mock.EventIDFunc()
}

// EventIDCalls gets all the calls that were made to EventID.
// Check the length with:
//
//	len(mockedEnvelope.EventIDCalls())
func (mock *EnvelopeMock) EventIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockEventID.RLock()
	calls = mock.calls.EventID
	mock.lockEventID.RUnlock()
	return calls
}

// Metadata calls MetadataFunc.
func (mock *EnvelopeMock) Metadata() map[string]interface{} {
	if mock.MetadataFunc == nil {
		panic("EnvelopeMock.MetadataFunc: method is nil but Envelope.Metadata was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMetadata.Lock()
	mock.calls.Metadata = append(mock.calls.Metadata, callInfo)
	mock.lockMetadata.Unlock()
	return mock.MetadataFunc()
}

// MetadataCalls gets all the calls that were made to Metadata.
// Check the length with:
//
//	len(mockedEnvelope.MetadataCalls())
func (mock *EnvelopeMock) MetadataCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMetadata.RLock()
	calls = mock.calls.Metadata
	mock.lockMetadata.RUnlock()
	return calls
}

// Timestamp calls TimestampFunc.
func (mock *EnvelopeMock) Timestamp() time.Time {
	if mock.TimestampFunc == nil {
		panic("EnvelopeMock.TimestampFunc: method is nil but Envelope.Timestamp was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTimestamp.Lock()
	mock.calls.Timestamp = append(mock.calls.Timestamp, callInfo)
	mock.lockTimestamp.Unlock()
	return mock.TimestampFunc()
}

// TimestampCalls gets all the calls that were made to Timestamp.
// Check the length with:
//
//	len(mockedEnvelope.TimestampCalls())
func (mock *EnvelopeMock) TimestampCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTimestamp.RLock()
	calls = mock.calls.Timestamp
	mock.lockTimestamp.RUnlock()
	return calls
}
