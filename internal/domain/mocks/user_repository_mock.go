// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/akeemphilbert/pericarp/internal/domain"
	"github.com/segmentio/ksuid"
	"sync"
)

// Ensure, that UserRepositoryMock does implement domain.UserRepository.
// If this is not the case, regenerate this file with moq.
var _ domain.UserRepository = &UserRepositoryMock{}

// UserRepositoryMock is a mock implementation of domain.UserRepository.
//
//	func TestSomethingThatUsesUserRepository(t *testing.T) {
//
//		// make and configure a mocked domain.UserRepository
//		mockedUserRepository := &UserRepositoryMock{
//			DeleteFunc: func(id ksuid.KSUID) error {
//				panic("mock out the Delete method")
//			},
//			FindByEmailFunc: func(email string) (*domain.User, error) {
//				panic("mock out the FindByEmail method")
//			},
//			FindByIDFunc: func(id ksuid.KSUID) (*domain.User, error) {
//				panic("mock out the FindByID method")
//			},
//			LoadFromVersionFunc: func(id ksuid.KSUID, version int) (*domain.User, error) {
//				panic("mock out the LoadFromVersion method")
//			},
//			SaveFunc: func(user *domain.User) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedUserRepository in code that requires domain.UserRepository
//		// and then make assertions.
//
//	}
type UserRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(id ksuid.KSUID) error

	// FindByEmailFunc mocks the FindByEmail method.
	FindByEmailFunc func(email string) (*domain.User, error)

	// FindByIDFunc mocks the FindByID method.
	FindByIDFunc func(id ksuid.KSUID) (*domain.User, error)

	// LoadFromVersionFunc mocks the LoadFromVersion method.
	LoadFromVersionFunc func(id ksuid.KSUID, version int) (*domain.User, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(user *domain.User) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// ID is the id argument value.
			ID ksuid.KSUID
		}
		// FindByEmail holds details about calls to the FindByEmail method.
		FindByEmail []struct {
			// Email is the email argument value.
			Email string
		}
		// FindByID holds details about calls to the FindByID method.
		FindByID []struct {
			// ID is the id argument value.
			ID ksuid.KSUID
		}
		// LoadFromVersion holds details about calls to the LoadFromVersion method.
		LoadFromVersion []struct {
			// ID is the id argument value.
			ID ksuid.KSUID
			// Version is the version argument value.
			Version int
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// User is the user argument value.
			User *domain.User
		}
	}
	lockDelete          sync.RWMutex
	lockFindByEmail     sync.RWMutex
	lockFindByID        sync.RWMutex
	lockLoadFromVersion sync.RWMutex
	lockSave            sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *UserRepositoryMock) Delete(id ksuid.KSUID) error {
	if mock.DeleteFunc == nil {
		panic("UserRepositoryMock.DeleteFunc: method is nil but UserRepository.Delete was just called")
	}
	callInfo := struct {
		ID ksuid.KSUID
	}{
		ID: id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedUserRepository.DeleteCalls())
func (mock *UserRepositoryMock) DeleteCalls() []struct {
	ID ksuid.KSUID
} {
	var calls []struct {
		ID ksuid.KSUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// FindByEmail calls FindByEmailFunc.
func (mock *UserRepositoryMock) FindByEmail(email string) (*domain.User, error) {
	if mock.FindByEmailFunc == nil {
		panic("UserRepositoryMock.FindByEmailFunc: method is nil but UserRepository.FindByEmail was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	mock.lockFindByEmail.Lock()
	mock.calls.FindByEmail = append(mock.calls.FindByEmail, callInfo)
	mock.lockFindByEmail.Unlock()
	return mock.FindByEmailFunc(email)
}

// FindByEmailCalls gets all the calls that were made to FindByEmail.
// Check the length with:
//
//	len(mockedUserRepository.FindByEmailCalls())
func (mock *UserRepositoryMock) FindByEmailCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	mock.lockFindByEmail.RLock()
	calls = mock.calls.FindByEmail
	mock.lockFindByEmail.RUnlock()
	return calls
}

// FindByID calls FindByIDFunc.
func (mock *UserRepositoryMock) FindByID(id ksuid.KSUID) (*domain.User, error) {
	if mock.FindByIDFunc == nil {
		panic("UserRepositoryMock.FindByIDFunc: method is nil but UserRepository.FindByID was just called")
	}
	callInfo := struct {
		ID ksuid.KSUID
	}{
		ID: id,
	}
	mock.lockFindByID.Lock()
	mock.calls.FindByID = append(mock.calls.FindByID, callInfo)
	mock.lockFindByID.Unlock()
	return mock.FindByIDFunc(id)
}

// FindByIDCalls gets all the calls that were made to FindByID.
// Check the length with:
//
//	len(mockedUserRepository.FindByIDCalls())
func (mock *UserRepositoryMock) FindByIDCalls() []struct {
	ID ksuid.KSUID
} {
	var calls []struct {
		ID ksuid.KSUID
	}
	mock.lockFindByID.RLock()
	calls = mock.calls.FindByID
	mock.lockFindByID.RUnlock()
	return calls
}

// LoadFromVersion calls LoadFromVersionFunc.
func (mock *UserRepositoryMock) LoadFromVersion(id ksuid.KSUID, version int) (*domain.User, error) {
	if mock.LoadFromVersionFunc == nil {
		panic("UserRepositoryMock.LoadFromVersionFunc: method is nil but UserRepository.LoadFromVersion was just called")
	}
	callInfo := struct {
		ID      ksuid.KSUID
		Version int
	}{
		ID:      id,
		Version: version,
	}
	mock.lockLoadFromVersion.Lock()
	mock.calls.LoadFromVersion = append(mock.calls.LoadFromVersion, callInfo)
	mock.lockLoadFromVersion.Unlock()
	return mock.LoadFromVersionFunc(id, version)
}

// LoadFromVersionCalls gets all the calls that were made to LoadFromVersion.
// Check the length with:
//
//	len(mockedUserRepository.LoadFromVersionCalls())
func (mock *UserRepositoryMock) LoadFromVersionCalls() []struct {
	ID      ksuid.KSUID
	Version int
} {
	var calls []struct {
		ID      ksuid.KSUID
		Version int
	}
	mock.lockLoadFromVersion.RLock()
	calls = mock.calls.LoadFromVersion
	mock.lockLoadFromVersion.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *UserRepositoryMock) Save(user *domain.User) error {
	if mock.SaveFunc == nil {
		panic("UserRepositoryMock.SaveFunc: method is nil but UserRepository.Save was just called")
	}
	callInfo := struct {
		User *domain.User
	}{
		User: user,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(user)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedUserRepository.SaveCalls())
func (mock *UserRepositoryMock) SaveCalls() []struct {
	User *domain.User
} {
	var calls []struct {
		User *domain.User
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}
