package infrastructure

import (
	"context"
	"fmt"

	"github.com/segmentio/ksuid"
	"github.com/akeemphilbert/pericarp/pkg/domain"
	
	appDomain "{{.ProjectName}}/internal/domain"
)

// {{.Name}}EventSourcingRepository implements {{.Name}}Repository using event sourcing
type {{.Name}}EventSourcingRepository struct {
	eventStore domain.EventStore
	logger     domain.Logger
}

// New{{.Name}}EventSourcingRepository creates a new event sourcing repository for {{.Name | lower}}s
func New{{.Name}}EventSourcingRepository(eventStore domain.EventStore, logger domain.Logger) *{{.Name}}EventSourcingRepository {
	return &{{.Name}}EventSourcingRepository{
		eventStore: eventStore,
		logger:     logger,
	}
}

// Save persists a {{.Name | lower}} aggregate by storing its uncommitted events
func (r *{{.Name}}EventSourcingRepository) Save(ctx context.Context, {{.Name | camelCase}} *appDomain.{{.Name}}) error {
	if {{.Name | camelCase}} == nil {
		return fmt.Errorf("{{.Name | camelCase}} cannot be nil")
	}

	events := {{.Name | camelCase}}.UncommittedEvents()
	if len(events) == 0 {
		r.logger.Debug("No uncommitted events to save for {{.Name | lower}} %s", {{.Name | camelCase}}.ID())
		return nil
	}

	// Store events
	if _, err := r.eventStore.Save(ctx, events); err != nil {
		return fmt.Errorf("failed to save events for {{.Name | lower}} %s: %w", {{.Name | camelCase}}.ID(), err)
	}

	// Mark events as committed
	{{.Name | camelCase}}.MarkEventsAsCommitted()
	
	r.logger.Debug("Saved %d events for {{.Name | lower}} %s", len(events), {{.Name | camelCase}}.ID())
	return nil
}

// Load retrieves a {{.Name | lower}} by ID by replaying its events
func (r *{{.Name}}EventSourcingRepository) Load(ctx context.Context, id ksuid.KSUID) (*appDomain.{{.Name}}, error) {
	aggregateID := id.String() // ✅ Correct conversion
	envelopes, err := r.eventStore.Load(ctx, aggregateID)
	if err != nil {
		return nil, fmt.Errorf("failed to load events for {{.Name | lower}} %s: %w", aggregateID, err)
	}

	if len(envelopes) == 0 {
		return nil, fmt.Errorf("{{.Name | lower}} not found: %s", aggregateID)
	}

	// Extract events from envelopes
	events := make([]domain.Event, len(envelopes))
	for i, envelope := range envelopes {
		events[i] = envelope.Event()
	}

	// Create empty aggregate and load from history
	{{.Name | camelCase}} := &appDomain.{{.Name}}{}
	{{.Name | camelCase}}.LoadFromHistory(events)

	r.logger.Debug("Loaded {{.Name | lower}} %s from %d events", aggregateID, len(events))
	return {{.Name | camelCase}}, nil
}

// Delete removes a {{.Name | lower}} by ID (soft delete via event)
func (r *{{.Name}}EventSourcingRepository) Delete(ctx context.Context, id ksuid.KSUID) error {
	// Load the aggregate first
	{{.Name | camelCase}}, err := r.Load(ctx, id)
	if err != nil {
		return fmt.Errorf("failed to load {{.Name | lower}} for deletion: %w", err)
	}

	// Create deletion event (this would need to be implemented in the aggregate)
	// For now, we'll return an error indicating this needs implementation
	return fmt.Errorf("delete operation not implemented for {{.Name | lower}} - requires domain method")
}

// Exists checks if a {{.Name | lower}} exists by ID
func (r *{{.Name}}EventSourcingRepository) Exists(ctx context.Context, id ksuid.KSUID) (bool, error) {
	aggregateID := id.String() // ✅ Correct conversion
	envelopes, err := r.eventStore.Load(ctx, aggregateID)
	if err != nil {
		return false, fmt.Errorf("failed to check existence of {{.Name | lower}} %s: %w", aggregateID, err)
	}

	return len(envelopes) > 0, nil
}

{{range .Properties}}{{if eq (.Type | goType) "string"}}
// FindBy{{.Name | pascalCase}} finds {{$.Name | lower}}s by {{.Name | lower}}
// Note: This is a simplified implementation. In a real event-sourced system,
// you would typically use read models/projections for queries
func (r *{{$.Name}}EventSourcingRepository) FindBy{{.Name | pascalCase}}(ctx context.Context, {{.Name | camelCase}} {{.Type | goType}}) ([]*appDomain.{{$.Name}}, error) {
	// This would typically query a read model/projection
	// For now, return an error indicating this needs a proper read model implementation
	return nil, fmt.Errorf("FindBy{{.Name | pascalCase}} requires read model implementation")
}
{{end}}{{end}}

// FindAll retrieves all {{.Name | lower}}s with pagination
// Note: This is a simplified implementation. In a real event-sourced system,
// you would typically use read models/projections for queries
func (r *{{.Name}}EventSourcingRepository) FindAll(ctx context.Context, limit, offset int) ([]*appDomain.{{.Name}}, error) {
	// This would typically query a read model/projection
	// For now, return an error indicating this needs a proper read model implementation
	return nil, fmt.Errorf("FindAll requires read model implementation")
}

// Count returns the total number of {{.Name | lower}}s
// Note: This is a simplified implementation. In a real event-sourced system,
// you would typically use read models/projections for queries
func (r *{{.Name}}EventSourcingRepository) Count(ctx context.Context) (int64, error) {
	// This would typically query a read model/projection
	// For now, return an error indicating this needs a proper read model implementation
	return 0, fmt.Errorf("Count requires read model implementation")
}