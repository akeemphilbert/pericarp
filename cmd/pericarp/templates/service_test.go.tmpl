package application

import (
	"context"
	"testing"

	"github.com/segmentio/ksuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"{{.ProjectName}}/internal/domain"
	"{{.ProjectName}}/test/mocks"
)

func Test{{.Entity.Name}}Service_Create(t *testing.T) {
	tests := []struct {
		name    string
		request *Create{{.Entity.Name}}Request
		setup   func(*mocks.Mock{{.Entity.Name}}Repository, *mocks.MockLogger)
		wantErr bool
	}{
		{
			name: "successful creation",
			request: &Create{{.Entity.Name}}Request{
				{{range .Entity.Properties}}{{if and .Required (ne .Name "Id")}}{{.Name}}: {{if eq .Type "string"}}"test{{.Name}}"{{else if eq .Type "int"}}123{{else}}test{{.Name}}{{end}},
				{{end}}{{end}}
			},
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				repo.On("Save", mock.Anything, mock.AnythingOfType("*domain.{{.Entity.Name}}")).Return(nil)
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything)
				logger.On("Info", mock.Anything, mock.Anything, mock.Anything)
			},
			wantErr: false,
		},
		{
			name:    "nil request",
			request: nil,
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything)
				logger.On("Error", mock.Anything, mock.Anything, mock.Anything)
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &mocks.Mock{{.Entity.Name}}Repository{}
			mockLogger := &mocks.MockLogger{}
			
			tt.setup(mockRepo, mockLogger)
			
			service := New{{.Entity.Name}}Service(mockRepo, mockLogger)
			
			result, err := service.Create(context.Background(), tt.request)
			
			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.NotNil(t, result.{{.Entity.Name}})
			}
			
			mockRepo.AssertExpectations(t)
			mockLogger.AssertExpectations(t)
		})
	}
}

func Test{{.Entity.Name}}Service_GetById(t *testing.T) {
	testID := ksuid.New()
	test{{.Entity.Name}} := &domain.{{.Entity.Name}}{
		Id: testID,
		{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}}: {{if eq .Type "string"}}"test{{.Name}}"{{else if eq .Type "int"}}123{{else}}test{{.Name}}{{end}},
		{{end}}{{end}}
	}

	tests := []struct {
		name    string
		id      ksuid.KSUID
		setup   func(*mocks.Mock{{.Entity.Name}}Repository, *mocks.MockLogger)
		want    *domain.{{.Entity.Name}}
		wantErr bool
	}{
		{
			name: "successful retrieval",
			id:   testID,
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				repo.On("GetById", mock.Anything, testID).Return(test{{.Entity.Name}}, nil)
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything)
			},
			want:    test{{.Entity.Name}},
			wantErr: false,
		},
		{
			name: "not found",
			id:   testID,
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				repo.On("GetById", mock.Anything, testID).Return(nil, nil)
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything)
				logger.On("Warn", mock.Anything, mock.Anything, mock.Anything)
			},
			want:    nil,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &mocks.Mock{{.Entity.Name}}Repository{}
			mockLogger := &mocks.MockLogger{}
			
			tt.setup(mockRepo, mockLogger)
			
			service := New{{.Entity.Name}}Service(mockRepo, mockLogger)
			
			result, err := service.GetById(context.Background(), tt.id)
			
			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.want, result.{{.Entity.Name}})
			}
			
			mockRepo.AssertExpectations(t)
			mockLogger.AssertExpectations(t)
		})
	}
}

func Test{{.Entity.Name}}Service_Update(t *testing.T) {
	testID := ksuid.New()
	existing{{.Entity.Name}} := &domain.{{.Entity.Name}}{
		Id: testID,
		{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}}: {{if eq .Type "string"}}"original{{.Name}}"{{else if eq .Type "int"}}123{{else}}original{{.Name}}{{end}},
		{{end}}{{end}}
	}

	tests := []struct {
		name    string
		id      ksuid.KSUID
		request *Update{{.Entity.Name}}Request
		setup   func(*mocks.Mock{{.Entity.Name}}Repository, *mocks.MockLogger)
		wantErr bool
	}{
		{
			name: "successful update",
			id:   testID,
			request: &Update{{.Entity.Name}}Request{
				{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}}: {{if eq .Type "string"}}stringPtr("updated{{.Name}}"){{else if eq .Type "int"}}intPtr(456){{else}}ptr(updated{{.Name}}){{end}},
				{{end}}{{end}}
			},
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				repo.On("GetById", mock.Anything, testID).Return(existing{{.Entity.Name}}, nil)
				repo.On("Save", mock.Anything, mock.AnythingOfType("*domain.{{.Entity.Name}}")).Return(nil)
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything)
				logger.On("Info", mock.Anything, mock.Anything, mock.Anything)
			},
			wantErr: false,
		},
		{
			name: "not found",
			id:   testID,
			request: &Update{{.Entity.Name}}Request{},
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				repo.On("GetById", mock.Anything, testID).Return(nil, nil)
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything)
				logger.On("Warn", mock.Anything, mock.Anything, mock.Anything)
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &mocks.Mock{{.Entity.Name}}Repository{}
			mockLogger := &mocks.MockLogger{}
			
			tt.setup(mockRepo, mockLogger)
			
			service := New{{.Entity.Name}}Service(mockRepo, mockLogger)
			
			result, err := service.Update(context.Background(), tt.id, tt.request)
			
			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
			}
			
			mockRepo.AssertExpectations(t)
			mockLogger.AssertExpectations(t)
		})
	}
}

func Test{{.Entity.Name}}Service_Delete(t *testing.T) {
	testID := ksuid.New()
	existing{{.Entity.Name}} := &domain.{{.Entity.Name}}{
		Id: testID,
		{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}}: {{if eq .Type "string"}}"test{{.Name}}"{{else if eq .Type "int"}}123{{else}}test{{.Name}}{{end}},
		{{end}}{{end}}
	}

	tests := []struct {
		name    string
		id      ksuid.KSUID
		setup   func(*mocks.Mock{{.Entity.Name}}Repository, *mocks.MockLogger)
		wantErr bool
	}{
		{
			name: "successful deletion",
			id:   testID,
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				repo.On("GetById", mock.Anything, testID).Return(existing{{.Entity.Name}}, nil)
				repo.On("Delete", mock.Anything, testID).Return(nil)
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything)
				logger.On("Info", mock.Anything, mock.Anything, mock.Anything)
			},
			wantErr: false,
		},
		{
			name: "not found",
			id:   testID,
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				repo.On("GetById", mock.Anything, testID).Return(nil, nil)
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything)
				logger.On("Warn", mock.Anything, mock.Anything, mock.Anything)
			},
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &mocks.Mock{{.Entity.Name}}Repository{}
			mockLogger := &mocks.MockLogger{}
			
			tt.setup(mockRepo, mockLogger)
			
			service := New{{.Entity.Name}}Service(mockRepo, mockLogger)
			
			err := service.Delete(context.Background(), tt.id)
			
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
			
			mockRepo.AssertExpectations(t)
			mockLogger.AssertExpectations(t)
		})
	}
}

func Test{{.Entity.Name}}Service_List(t *testing.T) {
	test{{.Entity.Name}}s := []*domain.{{.Entity.Name}}{
		{
			Id: ksuid.New(),
			{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}}: {{if eq .Type "string"}}"test{{.Name}}1"{{else if eq .Type "int"}}123{{else}}test{{.Name}}1{{end}},
			{{end}}{{end}}
		},
		{
			Id: ksuid.New(),
			{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}}: {{if eq .Type "string"}}"test{{.Name}}2"{{else if eq .Type "int"}}456{{else}}test{{.Name}}2{{end}},
			{{end}}{{end}}
		},
	}

	tests := []struct {
		name    string
		request *List{{.Entity.Name}}Request
		setup   func(*mocks.Mock{{.Entity.Name}}Repository, *mocks.MockLogger)
		want    []*domain.{{.Entity.Name}}
		wantErr bool
	}{
		{
			name: "successful list",
			request: &List{{.Entity.Name}}Request{
				Limit:  10,
				Offset: 0,
			},
			setup: func(repo *mocks.Mock{{.Entity.Name}}Repository, logger *mocks.MockLogger) {
				repo.On("List", mock.Anything, 10, 0).Return(test{{.Entity.Name}}s, nil)
				repo.On("Count", mock.Anything).Return(int64(2), nil)
				logger.On("Debug", mock.Anything, mock.Anything, mock.Anything).Twice()
			},
			want:    test{{.Entity.Name}}s,
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &mocks.Mock{{.Entity.Name}}Repository{}
			mockLogger := &mocks.MockLogger{}
			
			tt.setup(mockRepo, mockLogger)
			
			service := New{{.Entity.Name}}Service(mockRepo, mockLogger)
			
			result, err := service.List(context.Background(), tt.request)
			
			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, result)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, result)
				assert.Equal(t, tt.want, result.{{.Entity.Name}}s)
			}
			
			mockRepo.AssertExpectations(t)
			mockLogger.AssertExpectations(t)
		})
	}
}

// Helper functions for pointer creation
func stringPtr(s string) *string {
	return &s
}

func intPtr(i int) *int {
	return &i
}