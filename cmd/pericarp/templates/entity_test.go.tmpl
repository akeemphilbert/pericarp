package domain

import (
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

{{$entityName := .Name}}
{{$entityLower := .Name | lower}}

func TestNew{{$entityName}}(t *testing.T) {
	tests := []struct {
		name    string
		{{range filterRequired .Properties}}{{.Name | camelCase}} {{.Type | goType}}
		{{end}}
		wantErr bool
	}{
		{
			name: "valid {{$entityLower}}",
			{{range filterRequired .Properties}}{{.Name | camelCase}}: {{if eq (.Type | goType) "string"}}"test-{{.Name | lower}}"{{else if eq (.Type | goType) "uuid.UUID"}}uuid.New(){{else if eq (.Type | goType) "int"}}123{{else if eq (.Type | goType) "bool"}}true{{else}}{{.Type | goType | zeroValue}}{{end}},
			{{end}}
			wantErr: false,
		},
		{{range filterRequired .Properties}}
		{
			name: "invalid {{$entityLower}} - empty {{.Name | lower}}",
			{{range filterRequired $.Properties}}{{if eq .Name $.Name}}{{.Name | camelCase}}: {{.Type | goType | zeroValue}},
			{{else}}{{.Name | camelCase}}: {{if eq (.Type | goType) "string"}}"test-{{.Name | lower}}"{{else if eq (.Type | goType) "uuid.UUID"}}uuid.New(){{else if eq (.Type | goType) "int"}}123{{else if eq (.Type | goType) "bool"}}true{{else}}{{.Type | goType | zeroValue}}{{end}},
			{{end}}{{end}}
			wantErr: true,
		},
		{{end}}
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			{{$entityLower}}, err := New{{$entityName}}({{range $i, $prop := (filterRequired .Properties)}}{{if $i}}, {{end}}tt.{{$prop.Name | camelCase}}{{end}})

			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, {{$entityLower}})
				return
			}

			require.NoError(t, err)
			require.NotNil(t, {{$entityLower}})

			// Verify properties
			{{range filterRequired .Properties}}assert.Equal(t, tt.{{.Name | camelCase}}, {{$entityLower}}.{{.Name | pascalCase}})
			{{end}}

			// Verify aggregate root properties
			assert.Equal(t, 1, {{$entityLower}}.Version())
			assert.NotEmpty(t, {{$entityLower}}.ID())
			assert.Len(t, {{$entityLower}}.UncommittedEvents(), 1)

			// Verify creation event
			events := {{$entityLower}}.UncommittedEvents()
			createdEvent, ok := events[0].(*{{$entityName}}CreatedEvent)
			assert.True(t, ok)
			assert.Equal(t, "{{$entityName}}Created", createdEvent.EventType())
		})
	}
}

{{range .Properties}}{{if not .Required}}
func Test{{$entityName}}_Set{{.Name | pascalCase}}(t *testing.T) {
	// Create a valid {{$entityLower}}
	{{$entityLower}}, err := New{{$entityName}}({{range $i, $prop := (filterRequired $.Properties)}}{{if $i}}, {{end}}{{if eq (.Type | goType) "string"}}"test-{{.Name | lower}}"{{else if eq (.Type | goType) "uuid.UUID"}}uuid.New(){{else if eq (.Type | goType) "int"}}123{{else if eq (.Type | goType) "bool"}}true{{else}}{{.Type | goType | zeroValue}}{{end}}{{end}})
	require.NoError(t, err)

	// Clear uncommitted events
	{{$entityLower}}.MarkEventsAsCommitted()

	// Set new value
	newValue := {{if eq (.Type | goType) "string"}}"updated-{{.Name | lower}}"{{else if eq (.Type | goType) "uuid.UUID"}}uuid.New(){{else if eq (.Type | goType) "int"}}456{{else if eq (.Type | goType) "bool"}}false{{else}}{{.Type | goType | zeroValue}}{{end}}
	{{$entityLower}}.Set{{.Name | pascalCase}}(newValue)

	// Verify the value was updated
	assert.Equal(t, newValue, {{$entityLower}}.{{.Name | pascalCase}})

	// Verify update event was recorded
	events := {{$entityLower}}.UncommittedEvents()
	assert.Len(t, events, 1)

	updateEvent, ok := events[0].(*{{$entityName}}{{.Name | pascalCase}}UpdatedEvent)
	assert.True(t, ok)
	assert.Equal(t, "{{$entityName}}{{.Name | pascalCase}}Updated", updateEvent.EventType())
	assert.Equal(t, newValue, updateEvent.{{.Name | pascalCase}})
}
{{end}}{{end}}

func Test{{$entityName}}_LoadFromHistory(t *testing.T) {
	// Create test events
	aggregateID := uuid.New()
	events := []Event{
		New{{$entityName}}CreatedEvent(aggregateID{{range filterRequired .Properties}}, {{if eq (.Type | goType) "string"}}"test-{{.Name | lower}}"{{else if eq (.Type | goType) "uuid.UUID"}}uuid.New(){{else if eq (.Type | goType) "int"}}123{{else if eq (.Type | goType) "bool"}}true{{else}}{{.Type | goType | zeroValue}}{{end}}{{end}}),
	}

	// Create empty {{$entityLower}} and load from history
	{{$entityLower}} := &{{$entityName}}{}
	{{$entityLower}}.LoadFromHistory(events)

	// Verify the {{$entityLower}} was reconstructed correctly
	assert.Equal(t, aggregateID, {{$entityLower}}.Id)
	{{range filterRequired .Properties}}assert.Equal(t, {{if eq (.Type | goType) "string"}}"test-{{.Name | lower}}"{{else if eq (.Type | goType) "uuid.UUID"}}uuid.New(){{else if eq (.Type | goType) "int"}}123{{else if eq (.Type | goType) "bool"}}true{{else}}{{.Type | goType | zeroValue}}{{end}}, {{$entityLower}}.{{.Name | pascalCase}})
	{{end}}
	assert.Equal(t, 1, {{$entityLower}}.Version())
}

func Test{{$entityName}}_MarkEventsAsCommitted(t *testing.T) {
	// Create a valid {{$entityLower}}
	{{$entityLower}}, err := New{{$entityName}}({{range $i, $prop := (filterRequired .Properties)}}{{if $i}}, {{end}}{{if eq (.Type | goType) "string"}}"test-{{.Name | lower}}"{{else if eq (.Type | goType) "uuid.UUID"}}uuid.New(){{else if eq (.Type | goType) "int"}}123{{else if eq (.Type | goType) "bool"}}true{{else}}{{.Type | goType | zeroValue}}{{end}}{{end}})
	require.NoError(t, err)

	// Verify there are uncommitted events
	assert.NotEmpty(t, {{$entityLower}}.UncommittedEvents())

	// Mark events as committed
	{{$entityLower}}.MarkEventsAsCommitted()

	// Verify events are cleared
	assert.Empty(t, {{$entityLower}}.UncommittedEvents())
}