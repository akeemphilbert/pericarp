package application

import (
	"context"
	"fmt"

	"github.com/segmentio/ksuid"
	"github.com/akeemphilbert/pericarp/pkg/domain"
example.com/project/internal/domain
)

{{$entityName := .Entity.Name}}
{{$entityLower := .Entity.Name | lower}}

// Get{{$entityName}}ByIdHandler handles Get{{$entityName}}ByIdQuery
type Get{{$entityName}}ByIdHandler struct {
	repository domain.{{$entityName}}Repository
	logger     domain.Logger
}

// NewGet{{$entityName}}ByIdHandler creates a new Get{{$entityName}}ByIdHandler
func NewGet{{$entityName}}ByIdHandler(repository domain.{{$entityName}}Repository, logger domain.Logger) *Get{{$entityName}}ByIdHandler {
	return &Get{{$entityName}}ByIdHandler{
		repository: repository,
		logger:     logger,
	}
}

// Handle processes the Get{{$entityName}}ByIdQuery
func (h *Get{{$entityName}}ByIdHandler) Handle(ctx context.Context, query Get{{$entityName}}ByIdQuery) (*domain.{{$entityName}}, error) {
	h.logger.Debug(fmt.Sprintf("Getting {{$entityLower}} by ID: %s", query.Id))

	// Validate query
	if err := query.Validate(); err != nil {
		return nil, fmt.Errorf("invalid query: %w", err)
	}

	// Load {{$entityLower}} from repository
	{{$entityLower}}, err := h.repository.Load(ctx, query.Id)
	if err != nil {
		return nil, fmt.Errorf("failed to load {{$entityLower}}: %w", err)
	}

	h.logger.Debug(fmt.Sprintf("Successfully retrieved {{$entityLower}} with ID: %s", {{$entityLower}}.ID()))
	return {{$entityLower}}, nil
}

// List{{$entityName}}Handler handles List{{$entityName}}Query
type List{{$entityName}}Handler struct {
	repository domain.{{$entityName}}Repository
	logger     domain.Logger
}

// NewList{{$entityName}}Handler creates a new List{{$entityName}}Handler
func NewList{{$entityName}}Handler(repository domain.{{$entityName}}Repository, logger domain.Logger) *List{{$entityName}}Handler {
	return &List{{$entityName}}Handler{
		repository: repository,
		logger:     logger,
	}
}

// Handle processes the List{{$entityName}}Query
func (h *List{{$entityName}}Handler) Handle(ctx context.Context, query List{{$entityName}}Query) ([]*domain.{{$entityName}}, error) {
	h.logger.Debug(fmt.Sprintf("Listing {{$entityLower}}s with limit: %d, offset: %d", query.Limit, query.Offset))

	// Validate query
	if err := query.Validate(); err != nil {
		return nil, fmt.Errorf("invalid query: %w", err)
	}

	// Set default values if not provided
	if query.Limit <= 0 {
		query.Limit = 10
	}
	if query.Offset < 0 {
		query.Offset = 0
	}

	// TODO: Implement list functionality in repository
	// This would require extending the repository interface with List method
	// For now, return empty slice as placeholder
	h.logger.Debug(fmt.Sprintf("List operation not yet implemented for {{$entityLower}}"))
	return []*domain.{{$entityName}}{}, fmt.Errorf("list operation not yet implemented")
}