package application

import (
	"context"
	"fmt"

	"github.com/segmentio/ksuid"
	"github.com/akeemphilbert/pericarp/pkg/domain"
	"{{.ProjectName}}/internal/domain"
)

// {{.Entity.Name}}Service provides business logic for {{.Entity.Name}} operations
type {{.Entity.Name}}Service struct {
	repository domain.{{.Entity.Name}}Repository
	logger     domain.Logger
}

// New{{.Entity.Name}}Service creates a new {{.Entity.Name}} service
func New{{.Entity.Name}}Service(repository domain.{{.Entity.Name}}Repository, logger domain.Logger) *{{.Entity.Name}}Service {
	return &{{.Entity.Name}}Service{
		repository: repository,
		logger:     logger,
	}
}

// Create creates a new {{.Entity.Name}}
func (s *{{.Entity.Name}}Service) Create(ctx context.Context, req *Create{{.Entity.Name}}Request) (*{{.Entity.Name}}Response, error) {
	s.logger.Debug("Creating new {{.Entity.Name | lower}}", "request", req)

	// Validate request
	if err := s.validateCreate{{.Entity.Name}}Request(req); err != nil {
		s.logger.Error("Invalid create {{.Entity.Name | lower}} request", "error", err)
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Create new {{.Entity.Name}} entity
	{{.Entity.Name | lower}} := &domain.{{.Entity.Name}}{
		Id: ksuid.New(),
		{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}}: req.{{.Name}},
		{{end}}{{end}}
	}

	// Save to repository
	if err := s.repository.Save(ctx, {{.Entity.Name | lower}}); err != nil {
		s.logger.Error("Failed to save {{.Entity.Name | lower}}", "error", err, "id", {{.Entity.Name | lower}}.Id)
		return nil, fmt.Errorf("failed to save {{.Entity.Name | lower}}: %w", err)
	}

	s.logger.Info("{{.Entity.Name}} created successfully", "id", {{.Entity.Name | lower}}.Id)

	return &{{.Entity.Name}}Response{
		{{.Entity.Name}}: {{.Entity.Name | lower}},
	}, nil
}

// GetById retrieves a {{.Entity.Name}} by ID
func (s *{{.Entity.Name}}Service) GetById(ctx context.Context, id ksuid.KSUID) (*{{.Entity.Name}}Response, error) {
	s.logger.Debug("Getting {{.Entity.Name | lower}} by ID", "id", id)

	{{.Entity.Name | lower}}, err := s.repository.GetById(ctx, id)
	if err != nil {
		s.logger.Error("Failed to get {{.Entity.Name | lower}}", "error", err, "id", id)
		return nil, fmt.Errorf("failed to get {{.Entity.Name | lower}}: %w", err)
	}

	if {{.Entity.Name | lower}} == nil {
		s.logger.Warn("{{.Entity.Name}} not found", "id", id)
		return nil, fmt.Errorf("{{.Entity.Name | lower}} not found")
	}

	return &{{.Entity.Name}}Response{
		{{.Entity.Name}}: {{.Entity.Name | lower}},
	}, nil
}

// Update updates an existing {{.Entity.Name}}
func (s *{{.Entity.Name}}Service) Update(ctx context.Context, id ksuid.KSUID, req *Update{{.Entity.Name}}Request) (*{{.Entity.Name}}Response, error) {
	s.logger.Debug("Updating {{.Entity.Name | lower}}", "id", id, "request", req)

	// Validate request
	if err := s.validateUpdate{{.Entity.Name}}Request(req); err != nil {
		s.logger.Error("Invalid update {{.Entity.Name | lower}} request", "error", err)
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Get existing {{.Entity.Name}}
	existing{{.Entity.Name}}, err := s.repository.GetById(ctx, id)
	if err != nil {
		s.logger.Error("Failed to get existing {{.Entity.Name | lower}}", "error", err, "id", id)
		return nil, fmt.Errorf("failed to get existing {{.Entity.Name | lower}}: %w", err)
	}

	if existing{{.Entity.Name}} == nil {
		s.logger.Warn("{{.Entity.Name}} not found for update", "id", id)
		return nil, fmt.Errorf("{{.Entity.Name | lower}} not found")
	}

	// Update fields
	{{range .Entity.Properties}}{{if ne .Name "Id"}}if req.{{.Name}} != nil {
		existing{{$.Entity.Name}}.{{.Name}} = *req.{{.Name}}
	}
	{{end}}{{end}}

	// Save updated {{.Entity.Name}}
	if err := s.repository.Save(ctx, existing{{.Entity.Name}}); err != nil {
		s.logger.Error("Failed to update {{.Entity.Name | lower}}", "error", err, "id", id)
		return nil, fmt.Errorf("failed to update {{.Entity.Name | lower}}: %w", err)
	}

	s.logger.Info("{{.Entity.Name}} updated successfully", "id", id)

	return &{{.Entity.Name}}Response{
		{{.Entity.Name}}: existing{{.Entity.Name}},
	}, nil
}

// Delete deletes a {{.Entity.Name}} by ID
func (s *{{.Entity.Name}}Service) Delete(ctx context.Context, id string) error {
	s.logger.Debug("Deleting {{.Entity.Name | lower}}", "id", id)

	// Check if {{.Entity.Name}} exists
	existing{{.Entity.Name}}, err := s.repository.GetById(ctx, id)
	if err != nil {
		s.logger.Error("Failed to get {{.Entity.Name | lower}} for deletion", "error", err, "id", id)
		return fmt.Errorf("failed to get {{.Entity.Name | lower}}: %w", err)
	}

	if existing{{.Entity.Name}} == nil {
		s.logger.Warn("{{.Entity.Name}} not found for deletion", "id", id)
		return fmt.Errorf("{{.Entity.Name | lower}} not found")
	}

	// Delete {{.Entity.Name}}
	if err := s.repository.Delete(ctx, id); err != nil {
		s.logger.Error("Failed to delete {{.Entity.Name | lower}}", "error", err, "id", id)
		return fmt.Errorf("failed to delete {{.Entity.Name | lower}}: %w", err)
	}

	s.logger.Info("{{.Entity.Name}} deleted successfully", "id", id)
	return nil
}

// List retrieves a list of {{.Entity.Name}}s with pagination
func (s *{{.Entity.Name}}Service) List(ctx context.Context, req *List{{.Entity.Name}}Request) (*List{{.Entity.Name}}Response, error) {
	s.logger.Debug("Listing {{.Entity.Name | lower}}s", "request", req)

	// Set default values
	if req.Limit <= 0 {
		req.Limit = 10
	}
	if req.Offset < 0 {
		req.Offset = 0
	}

	{{.Entity.Name | lower}}s, err := s.repository.List(ctx, req.Limit, req.Offset)
	if err != nil {
		s.logger.Error("Failed to list {{.Entity.Name | lower}}s", "error", err)
		return nil, fmt.Errorf("failed to list {{.Entity.Name | lower}}s: %w", err)
	}

	total, err := s.repository.Count(ctx)
	if err != nil {
		s.logger.Error("Failed to count {{.Entity.Name | lower}}s", "error", err)
		return nil, fmt.Errorf("failed to count {{.Entity.Name | lower}}s: %w", err)
	}

	s.logger.Debug("{{.Entity.Name}}s listed successfully", "count", len({{.Entity.Name | lower}}s), "total", total)

	return &List{{.Entity.Name}}Response{
		{{.Entity.Name}}s: {{.Entity.Name | lower}}s,
		Total:     total,
		Limit:     req.Limit,
		Offset:    req.Offset,
	}, nil
}

// Validation methods

func (s *{{.Entity.Name}}Service) validateCreate{{.Entity.Name}}Request(req *Create{{.Entity.Name}}Request) error {
	if req == nil {
		return fmt.Errorf("request cannot be nil")
	}

	{{range .Entity.Properties}}{{if and .Required (ne .Name "Id")}}if req.{{.Name}} == {{if eq .Type "string"}}""{{else if eq .Type "int"}}0{{else}}nil{{end}} {
		return fmt.Errorf("{{.Name | lower}} is required")
	}
	{{end}}{{end}}

	return nil
}

func (s *{{.Entity.Name}}Service) validateUpdate{{.Entity.Name}}Request(req *Update{{.Entity.Name}}Request) error {
	if req == nil {
		return fmt.Errorf("request cannot be nil")
	}

	// For update, all fields are optional (using pointers)
	// Add specific validation logic here if needed

	return nil
}

// Request and Response types

// Create{{.Entity.Name}}Request represents a request to create a new {{.Entity.Name}}
type Create{{.Entity.Name}}Request struct {
	{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}} {{.Type}} `json:"{{.Name | lower}}"{{if .Required}} validate:"required"{{end}}`
	{{end}}{{end}}
}

// Update{{.Entity.Name}}Request represents a request to update an existing {{.Entity.Name}}
type Update{{.Entity.Name}}Request struct {
	{{range .Entity.Properties}}{{if ne .Name "Id"}}{{.Name}} *{{.Type}} `json:"{{.Name | lower}},omitempty"`
	{{end}}{{end}}
}

// List{{.Entity.Name}}Request represents a request to list {{.Entity.Name}}s
type List{{.Entity.Name}}Request struct {
	Limit  int `json:"limit" validate:"min=1,max=100"`
	Offset int `json:"offset" validate:"min=0"`
}

// {{.Entity.Name}}Response represents a single {{.Entity.Name}} response
type {{.Entity.Name}}Response struct {
	{{.Entity.Name}} *domain.{{.Entity.Name}} `json:"{{.Entity.Name | lower}}"`
}

// List{{.Entity.Name}}Response represents a list of {{.Entity.Name}}s response
type List{{.Entity.Name}}Response struct {
	{{.Entity.Name}}s []*domain.{{.Entity.Name}} `json:"{{.Entity.Name | lower}}s"`
	Total     int64                    `json:"total"`
	Limit     int                      `json:"limit"`
	Offset    int                      `json:"offset"`
}