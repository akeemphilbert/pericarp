package domain

import (
	"errors"
	"time"

	"github.com/segmentio/ksuid"
	"github.com/akeemphilbert/pericarp/pkg/domain"
)

// {{.Name}} represents a {{.Name | lower}} aggregate root
// Generated from domain model following Pericarp aggregate patterns
type {{.Name}} struct {
	{{range .Properties}}{{.Name | pascalCase}} {{.Type | goType}} `{{jsonTag .Name .Required}}{{if .Validation}} {{validationTag .}}{{end}}`
	{{end}}
	
	// Aggregate root fields
	sequenceNo        int64
	uncommittedEvents []domain.Event
}

// New{{.Name}} creates a new {{.Name | lower}} aggregate
func New{{.Name}}({{range $i, $prop := (filterRequired .Properties)}}{{if $i}}, {{end}}{{$prop.Name | camelCase}} {{$prop.Type | goType}}{{end}}) (*{{.Name}}, error) {
	{{range filterRequired .Properties}}if {{.Name | camelCase}} == {{.Type | goType | zeroValue}} {
		return nil, errors.New("{{.Name | camelCase}} cannot be empty")
	}
	{{end}}

	{{.Name | camelCase}} := &{{.Name}}{
		{{range .Properties}}{{if .Required}}{{.Name | pascalCase}}: {{.Name | camelCase}},
		{{else}}{{.Name | pascalCase}}: {{.Type | goType | zeroValue}},
		{{end}}{{end}}
		sequenceNo: 1,
		uncommittedEvents: make([]domain.Event, 0),
	}

	// Record creation event
	event := New{{.Name}}CreatedEvent({{range $i, $prop := (filterRequired .Properties)}}{{if $i}}, {{end}}{{$prop.Name | camelCase}}{{end}})
	{{.Name | camelCase}}.recordEvent(event)

	return {{.Name | camelCase}}, nil
}

// ID returns the {{.Name | lower}}'s ID as a string
func ({{slice .Name 0 1 | lower}} *{{.Name}}) ID() string {
	return {{slice .Name 0 1 | lower}}.Id.String()
}

// SequenceNo returns the current sequence number of the aggregate
func ({{slice .Name 0 1 | lower}} *{{.Name}}) SequenceNo() int64 {
	return {{slice .Name 0 1 | lower}}.sequenceNo
}

// UncommittedEvents returns uncommitted events
func ({{slice .Name 0 1 | lower}} *{{.Name}}) UncommittedEvents() []domain.Event {
	return {{slice .Name 0 1 | lower}}.uncommittedEvents
}

// MarkEventsAsCommitted clears uncommitted events
func ({{slice .Name 0 1 | lower}} *{{.Name}}) MarkEventsAsCommitted() {
	{{slice .Name 0 1 | lower}}.uncommittedEvents = make([]domain.Event, 0)
}

// LoadFromHistory reconstructs aggregate from events
func ({{slice .Name 0 1 | lower}} *{{.Name}}) LoadFromHistory(events []domain.Event) {
	for _, event := range events {
		{{slice .Name 0 1 | lower}}.applyEvent(event)
		{{slice .Name 0 1 | lower}}.sequenceNo = event.SequenceNo()
	}
}

{{range .Methods}}
// {{.Name}} {{.Description}}
func ({{slice $.Name 0 1 | lower}} *{{$.Name}}) {{.Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{$param.Name}} {{$param.Type}}{{end}}) {{if .ReturnType}}{{.ReturnType}} {{end}}{
	{{if .Implementation}}{{.Implementation}}{{else}}// TODO: Implement {{.Name}} method
	panic("not implemented"){{end}}
}
{{end}}

// Update methods for properties
{{range .Properties}}{{if not .Required}}
// Set{{.Name | pascalCase}} updates the {{.Name | lower}} field
func ({{slice $.Name 0 1 | lower}} *{{$.Name}}) Set{{.Name | pascalCase}}({{.Name | camelCase}} {{.Type | goType}}) {
	if {{slice $.Name 0 1 | lower}}.{{.Name | pascalCase}} != {{.Name | camelCase}} {
		{{slice $.Name 0 1 | lower}}.{{.Name | pascalCase}} = {{.Name | camelCase}}
		
		// Record update event
		event := New{{$.Name}}{{.Name | pascalCase}}UpdatedEvent({{slice $.Name 0 1 | lower}}.Id, {{.Name | camelCase}})
		{{slice $.Name 0 1 | lower}}.recordEvent(event)
	}
}
{{end}}{{end}}

// recordEvent adds an event to uncommitted events
func ({{slice .Name 0 1 | lower}} *{{.Name}}) recordEvent(event domain.Event) {
	{{slice .Name 0 1 | lower}}.uncommittedEvents = append({{slice .Name 0 1 | lower}}.uncommittedEvents, event)
}

// applyEvent applies an event to aggregate state
func ({{slice .Name 0 1 | lower}} *{{.Name}}) applyEvent(event domain.Event) {
	switch e := event.(type) {
	case *{{.Name}}CreatedEvent:
		{{slice .Name 0 1 | lower}}.Id = e.AggregateID
		{{range filterRequired .Properties}}{{slice $.Name 0 1 | lower}}.{{.Name | pascalCase}} = e.{{.Name | pascalCase}}
		{{end}}
	{{range .Properties}}{{if not .Required}}case *{{$.Name}}{{.Name | pascalCase}}UpdatedEvent:
		{{slice $.Name 0 1 | lower}}.{{.Name | pascalCase}} = e.{{.Name | pascalCase}}
	{{end}}{{end}}
	}
}