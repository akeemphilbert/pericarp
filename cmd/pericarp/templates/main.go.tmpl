package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/akeemphilbert/pericarp/pkg/application"
	"github.com/akeemphilbert/pericarp/pkg/domain"
	"github.com/akeemphilbert/pericarp/pkg/infrastructure"
	"{{.ProjectName}}/internal/application"
	"{{.ProjectName}}/internal/domain"
	"{{.ProjectName}}/internal/infrastructure"
)

func main() {
	// Create context that listens for the interrupt signal from the OS
	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	// Initialize logger
	logger := infrastructure.NewLogger()
	logger.Info("Starting {{.ProjectName}} application")

	// Initialize configuration
	config, err := infrastructure.LoadConfig()
	if err != nil {
		logger.Error("Failed to load configuration: " + err.Error())
		os.Exit(1)
	}

	// Initialize database
	db, err := infrastructure.NewDatabase(config.Database)
	if err != nil {
		logger.Error("Failed to initialize database: " + err.Error())
		os.Exit(1)
	}
	defer db.Close()

	// Initialize event store
	eventStore, err := infrastructure.NewEventStore(db, logger)
	if err != nil {
		logger.Error("Failed to initialize event store: " + err.Error())
		os.Exit(1)
	}

	// Initialize event dispatcher
	eventDispatcher := infrastructure.NewEventDispatcher(logger)

	// Initialize unit of work
	unitOfWork := infrastructure.NewUnitOfWork(eventStore, eventDispatcher, logger)

	// Initialize repositories
	{{range .Entities}}{{.Name | camelCase}}Repository := infrastructure.New{{.Name}}Repository(eventStore, logger)
	{{end}}

	// Initialize command handlers
	{{range .Entities}}create{{.Name}}Handler := application.NewCreate{{.Name}}Handler({{.Name | camelCase}}Repository, logger)
	update{{.Name}}Handler := application.NewUpdate{{.Name}}Handler({{.Name | camelCase}}Repository, logger)
	delete{{.Name}}Handler := application.NewDelete{{.Name}}Handler({{.Name | camelCase}}Repository, logger)
	{{end}}

	// Initialize query handlers
	{{range .Entities}}get{{.Name}}ByIdHandler := application.NewGet{{.Name}}ByIdHandler({{.Name | camelCase}}Repository, logger)
	list{{.Name}}Handler := application.NewList{{.Name}}Handler({{.Name | camelCase}}Repository, logger)
	{{end}}

	// Initialize command bus
	commandBus := application.NewCommandBus(logger)
	{{range .Entities}}commandBus.RegisterHandler("Create{{.Name}}Command", create{{.Name}}Handler)
	commandBus.RegisterHandler("Update{{.Name}}Command", update{{.Name}}Handler)
	commandBus.RegisterHandler("Delete{{.Name}}Command", delete{{.Name}}Handler)
	{{end}}

	// Initialize query bus
	queryBus := application.NewQueryBus(logger)
	{{range .Entities}}queryBus.RegisterHandler("Get{{.Name}}ByIdQuery", get{{.Name}}ByIdHandler)
	queryBus.RegisterHandler("List{{.Name}}Query", list{{.Name}}Handler)
	{{end}}

	// Initialize application service
	appService := application.NewService(commandBus, queryBus, unitOfWork, logger)

	// TODO: Initialize HTTP server, gRPC server, or other interfaces
	// This would depend on the specific requirements of your application

	logger.Info("{{.ProjectName}} application started successfully")

	// Wait for interrupt signal to gracefully shutdown
	<-ctx.Done()

	// Restore default behavior on the interrupt signal and notify user of shutdown
	stop()
	logger.Info("Shutting down {{.ProjectName}} application...")

	// TODO: Implement graceful shutdown logic
	// - Close HTTP server
	// - Close database connections
	// - Finish processing in-flight requests
	// - etc.

	logger.Info("{{.ProjectName}} application stopped")
}