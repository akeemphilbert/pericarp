package main

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"strconv"

	"github.com/segmentio/ksuid"
	"github.com/spf13/cobra"
	"{{.ProjectName}}/internal/application"
	"{{.ProjectName}}/internal/infrastructure"
)

var (
	// Build information - set via ldflags during build
	version   = "dev"
	commit    = "none"
	date      = "unknown"
	goVersion = "unknown"
)

// Global flags
var (
	verbose    bool
	configFile string
	outputJSON bool
)

{{range .Entities}}
// Helper function to initialize {{.Name}} service dependencies
func initialize{{.Name}}Service() (*application.{{.Name}}Service, func(), error) {
	logger := infrastructure.NewLogger()
	if verbose {
		logger.SetLevel("debug")
	}

	config, err := infrastructure.LoadConfig(configFile)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to load config: %w", err)
	}

	db, err := infrastructure.NewDatabase(config.Database)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to initialize database: %w", err)
	}

	eventStore, err := infrastructure.NewEventStore(db, logger)
	if err != nil {
		db.Close()
		return nil, nil, fmt.Errorf("failed to initialize event store: %w", err)
	}

	repository := infrastructure.New{{.Name}}Repository(eventStore, logger)
	service := application.New{{.Name}}Service(repository, logger)

	cleanup := func() {
		db.Close()
	}

	return service, cleanup, nil
}
{{end}}

// Helper function to output results
func outputResult(data interface{}, err error) error {
	if err != nil {
		return err
	}

	if outputJSON {
		jsonData, err := json.MarshalIndent(data, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal JSON: %w", err)
		}
		fmt.Println(string(jsonData))
	} else {
		// Pretty print for human readable output
		switch v := data.(type) {
		{{range .Entities}}case *application.{{.Name}}Response:
			fmt.Printf("{{.Name}} ID: %s\n", v.{{.Name}}.Id)
			{{range .Properties}}{{if ne .Name "Id"}}fmt.Printf("{{.Name}}: %v\n", v.{{$.Name}}.{{.Name}})
			{{end}}{{end}}
		case *application.List{{.Name}}Response:
			fmt.Printf("Found %d {{.Name | lower}}s (showing %d, offset %d):\n", v.Total, len(v.{{.Name}}s), v.Offset)
			for i, {{.Name | lower}} := range v.{{.Name}}s {
				fmt.Printf("\n%d. {{.Name}} ID: %s\n", i+1, {{.Name | lower}}.Id)
				{{range .Properties}}{{if ne .Name "Id"}}fmt.Printf("   {{.Name}}: %v\n", {{$.Name | lower}}.{{.Name}})
				{{end}}{{end}}
			}
		{{end}}default:
			fmt.Printf("%+v\n", data)
		}
	}
	return nil
}

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "{{.ProjectName}}",
	Short: "{{.ProjectName}} CLI application",
	Long: `{{.ProjectName}} is a CLI application built with Pericarp framework.
	
This application provides command-line interface for managing {{range $index, $entity := .Entities}}{{$entity.Name | lower}}s{{if not (last $index $.Entities)}}, {{end}}{{end}}.
It follows domain-driven design principles and provides comprehensive CRUD operations.`,
	Run: func(cmd *cobra.Command, args []string) {
		// Show help when no command is provided
		cmd.Help()
	},
}

{{range .Entities}}
// {{.Name | lower}}Cmd represents the {{.Name | lower}} command
var {{.Name | lower}}Cmd = &cobra.Command{
	Use:   "{{.Name | lower}}",
	Short: "Manage {{.Name | lower}}s",
	Long:  `Commands for managing {{.Name | lower}}s in the system.`,
}

// Command flags for {{.Name | lower}}
var (
	{{range .Properties}}{{if ne .Name "Id"}}{{.Name | lower}}Flag {{if eq .Type "string"}}string{{else if eq .Type "int"}}int{{else if eq .Type "bool"}}bool{{else}}string{{end}}
	{{end}}{{end}}limitFlag  int
	offsetFlag int
)

// create{{.Name}}Cmd represents the create {{.Name | lower}} command
var create{{.Name}}Cmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new {{.Name | lower}}",
	Long:  `Create a new {{.Name | lower}} in the system.`,
	Example: `  # Create a {{.Name | lower}}
  {{$.ProjectName}} {{.Name | lower}} create{{range .Properties}}{{if and .Required (ne .Name "Id")}} --{{.Name | lower}} "{{if eq .Type "string"}}example{{else if eq .Type "int"}}123{{else}}value{{end}}"{{end}}{{end}}`,
	RunE: func(cmd *cobra.Command, args []string) error {
		service, cleanup, err := initialize{{.Name}}Service()
		if err != nil {
			return err
		}
		defer cleanup()

		// Build create request
		req := &application.Create{{.Name}}Request{
			{{range .Properties}}{{if ne .Name "Id"}}{{.Name}}: {{.Name | lower}}Flag,
			{{end}}{{end}}
		}

		// Call service
		ctx := context.Background()
		result, err := service.Create(ctx, req)
		
		return outputResult(result, err)
	},
}

// get{{.Name}}Cmd represents the get {{.Name | lower}} command
var get{{.Name}}Cmd = &cobra.Command{
	Use:   "get [id]",
	Short: "Get a {{.Name | lower}} by ID",
	Long:  `Retrieve a {{.Name | lower}} by its unique identifier.`,
	Args:  cobra.ExactArgs(1),
	Example: `  # Get a {{.Name | lower}} by ID
  {{$.ProjectName}} {{.Name | lower}} get 2SwDCUuFQXNvVmoGBVJbUzSRHwd`,
	RunE: func(cmd *cobra.Command, args []string) error {
		service, cleanup, err := initialize{{.Name}}Service()
		if err != nil {
			return err
		}
		defer cleanup()

		// Parse ID
		id, err := ksuid.Parse(args[0])
		if err != nil {
			return fmt.Errorf("invalid KSUID format: %w", err)
		}

		// Call service
		ctx := context.Background()
		result, err := service.GetById(ctx, id)
		
		return outputResult(result, err)
	},
}

// list{{.Name}}Cmd represents the list {{.Name | lower}}s command
var list{{.Name}}Cmd = &cobra.Command{
	Use:   "list",
	Short: "List all {{.Name | lower}}s",
	Long:  `Retrieve a list of all {{.Name | lower}}s in the system with pagination support.`,
	Example: `  # List all {{.Name | lower}}s
  {{$.ProjectName}} {{.Name | lower}} list

  # List with pagination
  {{$.ProjectName}} {{.Name | lower}} list --limit 20 --offset 10`,
	RunE: func(cmd *cobra.Command, args []string) error {
		service, cleanup, err := initialize{{.Name}}Service()
		if err != nil {
			return err
		}
		defer cleanup()

		// Build list request
		req := &application.List{{.Name}}Request{
			Limit:  limitFlag,
			Offset: offsetFlag,
		}

		// Call service
		ctx := context.Background()
		result, err := service.List(ctx, req)
		
		return outputResult(result, err)
	},
}

// update{{.Name}}Cmd represents the update {{.Name | lower}} command
var update{{.Name}}Cmd = &cobra.Command{
	Use:   "update [id]",
	Short: "Update a {{.Name | lower}}",
	Long:  `Update an existing {{.Name | lower}} by its unique identifier.`,
	Args:  cobra.ExactArgs(1),
	Example: `  # Update a {{.Name | lower}}
  {{$.ProjectName}} {{.Name | lower}} update 2SwDCUuFQXNvVmoGBVJbUzSRHwd{{range .Properties}}{{if ne .Name "Id"}} --{{.Name | lower}} "{{if eq .Type "string"}}new value{{else if eq .Type "int"}}456{{else}}new value{{end}}"{{end}}{{end}}`,
	RunE: func(cmd *cobra.Command, args []string) error {
		service, cleanup, err := initialize{{.Name}}Service()
		if err != nil {
			return err
		}
		defer cleanup()

		// Parse ID
		id, err := ksuid.Parse(args[0])
		if err != nil {
			return fmt.Errorf("invalid KSUID format: %w", err)
		}

		// Build update request (only include fields that were explicitly set)
		req := &application.Update{{.Name}}Request{}
		{{range .Properties}}{{if ne .Name "Id"}}if cmd.Flags().Changed("{{.Name | lower}}") {
			{{if eq .Type "string"}}req.{{.Name}} = &{{.Name | lower}}Flag{{else if eq .Type "int"}}req.{{.Name}} = &{{.Name | lower}}Flag{{else if eq .Type "bool"}}req.{{.Name}} = &{{.Name | lower}}Flag{{else}}req.{{.Name}} = &{{.Name | lower}}Flag{{end}}
		}
		{{end}}{{end}}

		// Call service
		ctx := context.Background()
		result, err := service.Update(ctx, id, req)
		
		return outputResult(result, err)
	},
}

// delete{{.Name}}Cmd represents the delete {{.Name | lower}} command
var delete{{.Name}}Cmd = &cobra.Command{
	Use:   "delete [id]",
	Short: "Delete a {{.Name | lower}}",
	Long:  `Delete an existing {{.Name | lower}} by its unique identifier.`,
	Args:  cobra.ExactArgs(1),
	Example: `  # Delete a {{.Name | lower}}
  {{$.ProjectName}} {{.Name | lower}} delete 2SwDCUuFQXNvVmoGBVJbUzSRHwd`,
	RunE: func(cmd *cobra.Command, args []string) error {
		service, cleanup, err := initialize{{.Name}}Service()
		if err != nil {
			return err
		}
		defer cleanup()

		// Parse ID
		id, err := ksuid.Parse(args[0])
		if err != nil {
			return fmt.Errorf("invalid KSUID format: %w", err)
		}

		// Call service
		ctx := context.Background()
		err = service.Delete(ctx, id)
		
		if err != nil {
			return err
		}

		if outputJSON {
			fmt.Println(`{"success": true, "message": "{{.Name | lower}} deleted successfully"}`)
		} else {
			fmt.Printf("{{.Name}} deleted successfully\n")
		}
		
		return nil
	},
}
{{end}}

// versionCmd represents the version command
var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Show version information",
	Long:  `Display version information including build details.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Printf("{{.ProjectName}}\n")
		fmt.Printf("Version:    %s\n", version)
		fmt.Printf("Commit:     %s\n", commit)
		fmt.Printf("Built:      %s\n", date)
		fmt.Printf("Go version: %s\n", goVersion)
	},
}

func init() {
	// Add global flags
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "enable verbose output")
	rootCmd.PersistentFlags().StringVarP(&configFile, "config", "c", "", "config file (default is ./config.yaml)")
	rootCmd.PersistentFlags().BoolVar(&outputJSON, "json", false, "output results in JSON format")

	// Add version command
	rootCmd.AddCommand(versionCmd)

	{{range .Entities}}
	// Add flags for {{.Name | lower}} create command
	{{range .Properties}}{{if ne .Name "Id"}}create{{$.Name}}Cmd.Flags().{{if eq .Type "string"}}StringVar{{else if eq .Type "int"}}IntVar{{else if eq .Type "bool"}}BoolVar{{else}}StringVar{{end}}(&{{.Name | lower}}Flag, "{{.Name | lower}}", {{if eq .Type "string"}}"{{.DefaultValue}}"{{else if eq .Type "int"}}{{.DefaultValue | default "0"}}{{else if eq .Type "bool"}}{{.DefaultValue | default "false"}}{{else}}"{{.DefaultValue}}"{{end}}, "{{.Description | default (.Name | lower)}}")
	{{if .Required}}create{{$.Name}}Cmd.MarkFlagRequired("{{.Name | lower}}")
	{{end}}{{end}}{{end}}

	// Add flags for {{.Name | lower}} update command
	{{range .Properties}}{{if ne .Name "Id"}}update{{$.Name}}Cmd.Flags().{{if eq .Type "string"}}StringVar{{else if eq .Type "int"}}IntVar{{else if eq .Type "bool"}}BoolVar{{else}}StringVar{{end}}(&{{.Name | lower}}Flag, "{{.Name | lower}}", {{if eq .Type "string"}}"{{.DefaultValue}}"{{else if eq .Type "int"}}{{.DefaultValue | default "0"}}{{else if eq .Type "bool"}}{{.DefaultValue | default "false"}}{{else}}"{{.DefaultValue}}"{{end}}, "{{.Description | default (.Name | lower)}}")
	{{end}}{{end}}

	// Add flags for {{.Name | lower}} list command
	list{{.Name}}Cmd.Flags().IntVar(&limitFlag, "limit", 10, "maximum number of {{.Name | lower}}s to return")
	list{{.Name}}Cmd.Flags().IntVar(&offsetFlag, "offset", 0, "number of {{.Name | lower}}s to skip")

	// Add {{.Name | lower}} subcommands
	{{.Name | lower}}Cmd.AddCommand(create{{.Name}}Cmd)
	{{.Name | lower}}Cmd.AddCommand(get{{.Name}}Cmd)
	{{.Name | lower}}Cmd.AddCommand(list{{.Name}}Cmd)
	{{.Name | lower}}Cmd.AddCommand(update{{.Name}}Cmd)
	{{.Name | lower}}Cmd.AddCommand(delete{{.Name}}Cmd)
	
	// Add {{.Name | lower}} command to root
	rootCmd.AddCommand({{.Name | lower}}Cmd)
	{{end}}
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}